Error: Error!16 May 2013 4:53:15 amVM: Win32 - a SmalltalkImageImage: Squeak3.9 [latest update: #7067]SecurityManager state:Restricted: falseFileAccess: trueSocketAccess: trueWorking Dir E:\VUT\DP\soft\pntalkTrusted Dir E:\VUT\DP\soft\pntalk\MatronUntrusted Dir C:\Users\Matron\Documents\My SqueakPNtalkWorld(Object)>>error:	Receiver: a PNtalkWorld	Arguments and temporary variables: 		aString: 	'Error!'	Receiver's instance variables: 		name: 	nil		id: 	nil		parent: 	a PNtalkSimulation		idGen: 	a PNtalkIDGenerator		components: 	a Dictionary(1->a PNObject )		inputQueue: 	a SharedQueue		process: 	a Process in Process>>suspend		semaphore: 	a Semaphore()		status: 	#running		listProcesses: 	an OrderedCollection()		listInvocatedMethods: 	a Dictionary()		methodContext: 	a PNtalkMethodContext		busyObjects: 	a Dictionary()		executableObjects: 	a Dictionary()		nonActiveObjects: 	a Dictionary()		time: 	0		calendar: 	a PNtalkCalendar		timeSuspend: 	false		activity: 	true		executor: 	nil		garbageComponents: 	a Dictionary()PNtalkWorld(Object)>>error	Receiver: a PNtalkWorld	Arguments and temporary variables: 	Receiver's instance variables: 		name: 	nil		id: 	nil		parent: 	a PNtalkSimulation		idGen: 	a PNtalkIDGenerator		components: 	a Dictionary(1->a PNObject )		inputQueue: 	a SharedQueue		process: 	a Process in Process>>suspend		semaphore: 	a Semaphore()		status: 	#running		listProcesses: 	an OrderedCollection()		listInvocatedMethods: 	a Dictionary()		methodContext: 	a PNtalkMethodContext		busyObjects: 	a Dictionary()		executableObjects: 	a Dictionary()		nonActiveObjects: 	a Dictionary()		time: 	0		calendar: 	a PNtalkCalendar		timeSuspend: 	false		activity: 	true		executor: 	nil		garbageComponents: 	a Dictionary()[] in PNtalkWorld(PNtalkMaster)>>doExclusive: {[self error]}	Arguments and temporary variables: 		aBlock: 	[] in PNtalkWorld(PNtalkMaster)>>processBody {[self processMessage: msg...etc...[] in PNtalkWorld(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]}	Arguments and temporary variables: 		aBlock: 	[] in PNtalkWorld(PNtalkMaster)>>processBody {[self processMessage: msg...etc...		aFailBlock: 	[] in PNtalkWorld(PNtalkMaster)>>doExclusive: {[self error]}		ret: 	nil		ex: 	Error: Error!--- The full stack ---PNtalkWorld(Object)>>error:PNtalkWorld(Object)>>error[] in PNtalkWorld(PNtalkMaster)>>doExclusive: {[self error]}[] in PNtalkWorld(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]} - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -BlockContext>>valueWithPossibleArgs:[] in MethodContext(ContextPart)>>handleSignal: {[(self tempAt: 2)   valueWithPossibleArgs: {exception}]}BlockContext>>ensure:MethodContext(ContextPart)>>handleSignal:MethodContext(ContextPart)>>handleSignal:Error(Exception)>>signalError(Exception)>>signal:PNObject(Object)>>error:PNObject(Object)>>error[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]}BlockContext>>valueWithPossibleArgs:[] in MethodContext(ContextPart)>>handleSignal: {[(self tempAt: 2)   valueWithPossibleArgs: {exception}]}BlockContext>>ensure:MethodContext(ContextPart)>>handleSignal:MessageNotUnderstood(Exception)>>signalPNVariable(Object)>>doesNotUnderstand: #newPNtalkThread>>processMessage:withArguments:receiver:[] in PNAction>>DoIt {[context   processMessage: #new   withArguments: OrderedCollection new yours...]}PNAction>>valueInThread:variables:PNtalkThread>>performActionPNtalkThread>>performPNTransition>>performFor:PNtalkEvent>>performPNObject>>dStep[] in PNObject>>simulationStep {[self dStep]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[semaphore wait.  ret := aBlock value.  semaphore signal.  ^ ret]}BlockContext>>on:do:PNObject(PNtalkMaster)>>doExclusive:ifFail:PNObject(PNtalkMaster)>>doExclusive:PNObject>>simulationStep[] in PNtalkWorld>>dStep {[:object | object isActive   ifTrue: [object simulationStep]]}Array(SequenceableCollection)>>do:PNtalkWorld>>dStepPNtalkWorld>>nextStepPNtalkWorld(PNtalkMaster)>>performMessage:in:...etc...