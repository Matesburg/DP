Error: Error!19 May 2013 3:24:50 amVM: Win32 - a SmalltalkImageImage: Squeak3.9 [latest update: #7067]SecurityManager state:Restricted: falseFileAccess: trueSocketAccess: trueWorking Dir E:\VUT\DP\soft\pntalkTrusted Dir E:\VUT\DP\soft\pntalk\MatronUntrusted Dir C:\Users\Matron\Documents\My SqueakPNObject(Object)>>error:	Receiver: a PNObject	Arguments and temporary variables: 		aString: 	'Error!'	Receiver's instance variables: 		name: 	nil		id: 	2		parent: 	a PNtalkWorld		idGen: 	a PNtalkIDGenerator		components: 	a Dictionary(1->a PNProcess 4->a PNProcess )		inputQueue: 	a SharedQueue		process: 	a Process in Process>>suspend		semaphore: 	a Semaphore()		status: 	#running		listProcesses: 	an OrderedCollection()		listInvocatedMethods: 	a Dictionary()		methodContext: 	a PNProcess		class: 	a PNCompiledClass		calendar: 	a PNtalkCalendar		executable: 	false		random: 	a Random		listDependencies: 	a Dictionary(a PNtalkMessage->a PNtalkThread )		activity: 	true		proxies: 	a WeakRegistry(<this WeakRegistry is locked>; spac)PNObject(Object)>>error	Receiver: a PNObject	Arguments and temporary variables: 	Receiver's instance variables: 		name: 	nil		id: 	2		parent: 	a PNtalkWorld		idGen: 	a PNtalkIDGenerator		components: 	a Dictionary(1->a PNProcess 4->a PNProcess )		inputQueue: 	a SharedQueue		process: 	a Process in Process>>suspend		semaphore: 	a Semaphore()		status: 	#running		listProcesses: 	an OrderedCollection()		listInvocatedMethods: 	a Dictionary()		methodContext: 	a PNProcess		class: 	a PNCompiledClass		calendar: 	a PNtalkCalendar		executable: 	false		random: 	a Random		listDependencies: 	a Dictionary(a PNtalkMessage->a PNtalkThread )		activity: 	true		proxies: 	a WeakRegistry(<this WeakRegistry is locked>; spac)[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}	Arguments and temporary variables: 		aBlock: 	[] in PNObject(PNtalkMaster)>>processBody {[self processMessage: msg]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]}	Arguments and temporary variables: 		aBlock: 	[] in PNObject(PNtalkMaster)>>processBody {[self processMessage: msg]}		aFailBlock: 	[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}		ret: 	nil		ex: 	MessageNotUnderstood: PNObject>>hasAuthor:--- The full stack ---PNObject(Object)>>error:PNObject(Object)>>error[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]} - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -BlockContext>>valueWithPossibleArgs:[] in MethodContext(ContextPart)>>handleSignal: {[(self tempAt: 2)   valueWithPossibleArgs: {exception}]}BlockContext>>ensure:MethodContext(ContextPart)>>handleSignal:MessageNotUnderstood(Exception)>>signalPNObject(Object)>>doesNotUnderstand: #hasAuthor:PNObject>>testPort:PNtalkObjectProxy>>testPort:PNTransition>>processPort:withArguments:receiver:[] in PNTransGoalGuard>>DoIt {[context   processPort: #hasAuthor:   withArguments: (OrderedCollection new ...]}PNTransGoalGuard>>test:PNTransGoalGuard(PNTransGoal)>>testPNTransitionTesting>>forwardTestGuard:PNTransitionTesting>>testGuards:PNTransitionTesting>>testPNTransitionTesting>>complexTest:PNTransition>>test[] in PNProcess>>testTransitions {[:t |  t test   ifTrue: [^ t].  nil]}[] in Dictionary>>do: {[:assoc | aBlock value: assoc value]}Dictionary(Set)>>do:Dictionary>>do:PNProcess>>testTransitionsPNProcess>>test[] in PNObject>>dTest {[:item | exec := exec | item test]}[] in Dictionary>>do: {[:assoc | aBlock value: assoc value]}Dictionary(Set)>>do:Dictionary>>do:PNObject(PNtalkContainer)>>componentsDo:PNObject>>dTestPNProcess>>activatePNObject>>performDomainMessage:in:PNObject(PNtalkMaster)>>performMessage:in:PNObject(PNtalkMaster)>>processMessage:[] in PNObject(PNtalkMaster)>>processBody {[self processMessage: msg]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[semaphore wait.  ret := aBlock value.  semaphore signal.  ^ ret]}BlockContext>>on:do:PNObject(PNtalkMaster)>>doExclusive:ifFail:PNObject(PNtalkMaster)>>doExclusive:PNObject(PNtalkMaster)>>processBodyPNObject>>processBody...etc...