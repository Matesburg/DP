MessageNotUnderstood: PNParser>>parsingError6 May 2013 11:53:13 pmVM: Win32 - a SmalltalkImageImage: Squeak3.9 [latest update: #7067]SecurityManager state:Restricted: falseFileAccess: trueSocketAccess: trueWorking Dir E:\VUT\DP\soft\pntalkTrusted Dir E:\VUT\DP\soft\pntalk\MatronUntrusted Dir C:\Users\Matron\Documents\My SqueakPNParser(Object)>>doesNotUnderstand: #parsingError	Receiver: a PNParser	Arguments and temporary variables: 		aMessage: 	parsingError	Receiver's instance variables: 		source: 	nil		mark: 	nil		hereChar: 	nil		aheadChar: 	nil		token: 	nil		tokenType: 	nil		currentComment: 	nil		buffer: 	a WriteStream ''		typeTable: 	#(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xB...etc...		here: 	nil		hereType: 	nil		hereMark: 	nil		hereEnd: 	nil		prevMark: 	nil		prevEnd: 	nil		encoder: 	nil		requestor: 	nil		parseNode: 	nil		failBlock: 	nil		requestorOffset: 	nil		tempsMark: 	nil		doitFlag: 	nil		properties: 	nil		category: 	nil		actionsCollection: 	an OrderedCollection()		lexer: 	a Lex		alex: 	a LexerTPNParser>>expected:value:	Receiver: a PNParser	Arguments and temporary variables: 		t: 	#id		v: 	nil	Receiver's instance variables: 		source: 	nil		mark: 	nil		hereChar: 	nil		aheadChar: 	nil		token: 	nil		tokenType: 	nil		currentComment: 	nil		buffer: 	a WriteStream ''		typeTable: 	#(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xB...etc...		here: 	nil		hereType: 	nil		hereMark: 	nil		hereEnd: 	nil		prevMark: 	nil		prevEnd: 	nil		encoder: 	nil		requestor: 	nil		parseNode: 	nil		failBlock: 	nil		requestorOffset: 	nil		tempsMark: 	nil		doitFlag: 	nil		properties: 	nil		category: 	nil		actionsCollection: 	an OrderedCollection()		lexer: 	a Lex		alex: 	a LexerTPNParser>>expectedType:	Receiver: a PNParser	Arguments and temporary variables: 		t: 	#id	Receiver's instance variables: 		source: 	nil		mark: 	nil		hereChar: 	nil		aheadChar: 	nil		token: 	nil		tokenType: 	nil		currentComment: 	nil		buffer: 	a WriteStream ''		typeTable: 	#(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xB...etc...		here: 	nil		hereType: 	nil		hereMark: 	nil		hereEnd: 	nil		prevMark: 	nil		prevEnd: 	nil		encoder: 	nil		requestor: 	nil		parseNode: 	nil		failBlock: 	nil		requestorOffset: 	nil		tempsMark: 	nil		doitFlag: 	nil		properties: 	nil		category: 	nil		actionsCollection: 	an OrderedCollection()		lexer: 	a Lex		alex: 	a LexerTPNParser>>id	Receiver: a PNParser	Arguments and temporary variables: 		p: 	nil	Receiver's instance variables: 		source: 	nil		mark: 	nil		hereChar: 	nil		aheadChar: 	nil		token: 	nil		tokenType: 	nil		currentComment: 	nil		buffer: 	a WriteStream ''		typeTable: 	#(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xB...etc...		here: 	nil		hereType: 	nil		hereMark: 	nil		hereEnd: 	nil		prevMark: 	nil		prevEnd: 	nil		encoder: 	nil		requestor: 	nil		parseNode: 	nil		failBlock: 	nil		requestorOffset: 	nil		tempsMark: 	nil		doitFlag: 	nil		properties: 	nil		category: 	nil		actionsCollection: 	an OrderedCollection()		lexer: 	a Lex		alex: 	a LexerT--- The full stack ---PNParser(Object)>>doesNotUnderstand: #parsingErrorPNParser>>expected:value:PNParser>>expectedType:PNParser>>id - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -PNParser>>keyMessage:PNParser>>messagePNParser>>parseNetPNParser>>compileMethod:PNCompiledClass>>compileNet:PNCompiledClass>>addMethodAction[] in MenuItemMorph>>invokeWithEvent: {[(selArgCount := selector numArgs) = 0   ifTrue: [target perform: selector] ...]}BlockContext>>ensure:CursorWithMask(Cursor)>>showWhile:MenuItemMorph>>invokeWithEvent:MenuItemMorph>>mouseUp:MenuItemMorph>>handleMouseUp:MouseButtonEvent>>sentTo:MenuItemMorph(Morph)>>handleEvent:MorphicEventDispatcher>>dispatchDefault:with:MorphicEventDispatcher>>dispatchEvent:with:MenuItemMorph(Morph)>>processEvent:using:MorphicEventDispatcher>>dispatchDefault:with:MorphicEventDispatcher>>dispatchEvent:with:MenuMorph(Morph)>>processEvent:using:MenuMorph(Morph)>>processEvent:MenuMorph>>handleFocusEvent:[] in HandMorph>>sendFocusEvent:to:clear: {[ActiveHand := self.  ActiveEvent := anEvent.  result := focusHolder     han...]}[] in PasteUpMorph>>becomeActiveDuring: {[aBlock value]}...etc...