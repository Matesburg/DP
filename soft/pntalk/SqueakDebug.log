Error: Error!5 May 2013 2:53:12 amVM: Win32 - a SmalltalkImageImage: Squeak3.9 [latest update: #7067]SecurityManager state:Restricted: falseFileAccess: trueSocketAccess: trueWorking Dir E:\VUT\DP\soft\pntalkTrusted Dir E:\VUT\DP\soft\pntalk\MatronUntrusted Dir C:\Users\Matron\Documents\My SqueakPNObject(Object)>>error:	Receiver: a PNObject	Arguments and temporary variables: 		aString: 	'Error!'	Receiver's instance variables: 		name: 	nil		id: 	1		parent: 	a PNtalkWorld		idGen: 	a PNtalkIDGenerator		components: 	a Dictionary(1->a PNProcess )		inputQueue: 	a SharedQueue		process: 	a Process in Process>>suspend		semaphore: 	a Semaphore()		status: 	#running		listProcesses: 	an OrderedCollection()		listInvocatedMethods: 	a Dictionary()		methodContext: 	a PNtalkMethodContext		class: 	a PNCompiledClass		calendar: 	a PNtalkCalendar		executable: 	false		random: 	a Random		listDependencies: 	a Dictionary(a PNtalkMessage->a PNtalkThread )		activity: 	true		proxies: 	a WeakRegistry(<this WeakRegistry is locked>; spac)PNObject(Object)>>error	Receiver: a PNObject	Arguments and temporary variables: 	Receiver's instance variables: 		name: 	nil		id: 	1		parent: 	a PNtalkWorld		idGen: 	a PNtalkIDGenerator		components: 	a Dictionary(1->a PNProcess )		inputQueue: 	a SharedQueue		process: 	a Process in Process>>suspend		semaphore: 	a Semaphore()		status: 	#running		listProcesses: 	an OrderedCollection()		listInvocatedMethods: 	a Dictionary()		methodContext: 	a PNtalkMethodContext		class: 	a PNCompiledClass		calendar: 	a PNtalkCalendar		executable: 	false		random: 	a Random		listDependencies: 	a Dictionary(a PNtalkMessage->a PNtalkThread )		activity: 	true		proxies: 	a WeakRegistry(<this WeakRegistry is locked>; spac)[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}	Arguments and temporary variables: 		aBlock: 	[] in PNObject(PNtalkMaster)>>processBody {[self processMessage: msg]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]}	Arguments and temporary variables: 		aBlock: 	[] in PNObject(PNtalkMaster)>>processBody {[self processMessage: msg]}		aFailBlock: 	[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}		ret: 	nil		ex: 	MessageNotUnderstood: PNObject>>logout:--- The full stack ---PNObject(Object)>>error:PNObject(Object)>>error[] in PNObject(PNtalkMaster)>>doExclusive: {[self error]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[:ex | (Halt handles: ex)   ifTrue: [self halt.    ex resume]   ifFalse: [se...]} - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -BlockContext>>valueWithPossibleArgs:[] in MethodContext(ContextPart)>>handleSignal: {[(self tempAt: 2)   valueWithPossibleArgs: {exception}]}BlockContext>>ensure:MethodContext(ContextPart)>>handleSignal:MessageNotUnderstood(Exception)>>signalPNObject(Object)>>doesNotUnderstand: #logout:PNObject>>performDomainMessage:in:PNObject(PNtalkMaster)>>performMessage:in:PNObject(PNtalkMaster)>>processMessage:[] in PNObject(PNtalkMaster)>>processBody {[self processMessage: msg]}[] in PNObject(PNtalkMaster)>>doExclusive:ifFail: {[semaphore wait.  ret := aBlock value.  semaphore signal.  ^ ret]}BlockContext>>on:do:PNObject(PNtalkMaster)>>doExclusive:ifFail:PNObject(PNtalkMaster)>>doExclusive:PNObject(PNtalkMaster)>>processBodyPNObject>>processBody[] in PNObject(PNtalkMaster)>>start {[self processBody]}[] in BlockContext>>newProcess {[self value.  Processor terminateActive]}